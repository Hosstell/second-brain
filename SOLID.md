### **S — Single Responsibility Principle (Принцип единственной ответственности)**
**Класс должен иметь только одну причину для изменения.**
То есть у класса должна быть **одна и только одна ответственность** — он должен выполнять только одну функцию или решать одну задачу.
✅ Хорошо:
```python
class ReportGenerator:
    def generate(self):
        pass

class ReportPrinter:
    def print(self, report):
        pass
```

❌ Плохо (все в одном классе):
```python
class Report:
    def generate(self):
        pass

    def print(self):
        pass
```
---
### **O — Open/Closed Principle (Принцип открытости/закрытости)**
**Программные сущности должны быть открыты для расширения, но закрыты для изменения.**
Вы должны уметь добавлять новый функционал, не изменяя существующий код.
✅ Хорошо (расширение через наследование или композицию):
```python
class Shape:
    def area(self):
        pass

class Circle(Shape):
    def area(self):
        return 3.14 * self.radius ** 2
```
---
### **L — Liskov Substitution Principle (Принцип подстановки Лисков)**
**Объекты подклассов должны быть взаимозаменяемыми с объектами суперклассов.**
Если класс `S` является подклассом `T`, то объекты `T` могут быть заменены на `S` без изменения корректности программы.
❌ Плохо: подкласс нарушает ожидания родителя.  
✅ Хорошо: поведение наследника не ломает контракт базового класса.

---
### **I — Interface Segregation Principle (Принцип разделения интерфейса)**
**Лучше иметь несколько специализированных интерфейсов, чем один универсальный.**
Клиенты не должны зависеть от интерфейсов, которые они не используют.
✅ Хорошо:
```python
class Printable:
    def print(self): pass

class Scannable:
    def scan(self): pass
```

❌ Плохо (все в одном):
```python
class Machine:
    def print(self): pass
    def scan(self): pass
    def fax(self): pass
```
---
### **D — Dependency Inversion Principle (Принцип инверсии зависимостей)**
**Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций.**
**Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.**
✅ Хорошо:
```python
class MessageSender:
    def __init__(self, sender: SenderInterface):
        self.sender = sender
```
